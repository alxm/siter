#!/usr/bin/env python3

"""
    Copyright 2011 Alex Margarit

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""

import sys
import os
import enum
import time
import importlib

class File:
    def __init__(self, path, required = False):
        if required and not os.path.exists(path):
            Siter.error('Required file {} not found'.format(path))

        self.path = path
        self.required = required

    def get_path(self):
        return self.path

class Dir(File):
    def add_file(self, name, required = False):
        path = os.path.join(self.path, name)
        return TextFile(path, required)

    def copy_to(self, dst_dir):
        src = self.path + '/'
        dst = dst_dir.path

        Siter.info('Copying media from {} to {}'.format(src, dst))
        os.system('rsync -r --delete {} {}'.format(src, dst))

class TextFile(File):
    def __init__(self, path, required = False):
        File.__init__(self, path, required)

        self.content = ''
        self.lines = []

        try:
            with open(self.path, 'rU') as f:
                self.content = f.read()
                self.lines = self.content.splitlines()
        except FileNotFoundError:
            if self.required:
                Siter.error('Required file {} not found'.format(self.path))

    def get_line(self, number):
        if number < len(self.lines):
            return self.lines[number]
        elif self.required:
            Siter.error('Missing required line {}:{}'.format(self.path, number))
        else:
            return None

    def get_content(self):
        return self.content

class Dirs:
    def __init__(self):
        self.config = Dir('siter-config')
        self.media = Dir('siter-media')
        self.pages = Dir('siter-pages', True)
        self.template = Dir('siter-template', True)
        self.template_media = Dir('siter-template/media')

        self.out_root = Dir('siter-out')
        self.out_media = Dir('siter-out/media')
        self.out_template_media = Dir('siter-out/media/template-media')

class Files:
    def __init__(self, dirs):
        self.defs = dirs.config.add_file('defs')
        self.marker = dirs.config.add_file('marker')
        self.media = dirs.config.add_file('media')
        self.outdir = dirs.config.add_file('outdir')
        self.tags = dirs.config.add_file('tags')
        self.page_html = dirs.template.add_file('page.html', True)

class TokenType(enum.Enum):
    Rest = 0
    Text = 1
    Newline = 2
    Whitespace = 3
    TagOpen = 4
    TagClose = 5
    Block = 6

class Token:
    def __init__(self, t_type, text = None):
        self.t_type = t_type
        self.text = text
        self.tokens = []

    def resolve(self):
        if self.t_type is TokenType.Block:
            output = ''

            for t in self.tokens:
                output += t.resolve()

            return '{' + output + '}'
        else:
            return self.text

    def capture(self, *args):
        i = 0
        results = []

        for arg in args:
            if arg is TokenType.Rest:
                results.append(self.tokens[i:])
                break

            found = False

            while i < len(self.tokens):
                token = self.tokens[i]
                i += 1

                if token.t_type is arg:
                    found = True
                    results.append(token)
                    break

                if token.t_type is not TokenType.Newline and token.t_type is not TokenType.Whitespace:
                    break

            if not found:
                return None

        return results

    def is_variable(self):
        return self.capture(TokenType.Text)[0].resolve() == 'var'

    def capture_variable(self):
        # {var name *}
        results = self.capture(TokenType.Text, TokenType.Text, TokenType.Rest)

        name = results[1]
        body = results[2]

        return name, body

    def is_macro(self):
        return self.capture(TokenType.Text)[0].resolve() == 'fun'

    def capture_macro(self):
        # {fun name {args} body}
        results = self.capture(TokenType.Text, TokenType.Text, TokenType.Block, TokenType.Rest)

        name = results[1]
        args = [t for t in results[2].tokens if t.t_type is TokenType.Text]
        body = results[3]

        return name, args, body

    def is_call(self):
        results = self.capture(TokenType.Text)

        if results:
            name = results[0].resolve()
            return len(name) > 1 and name[0] == '`'

        return False

    def capture_call(self):
        # {name *}
        return self.capture(TokenType.Text)[0]

    def capture_args(self):
        # {name {arg1} {arg2} *}
        results = self.capture(TokenType.Text, TokenType.Rest)

        if len(results) < 2:
            Siter.error('No arguments for {}'.format(results[0].resolve()))

        return [t for t in results[1] if t.t_type is TokenType.Block]

class BindingType(enum.Enum):
    Variable = 0
    Macro = 1
    Function = 2

class Binding:
    def __init__(self, b_type, tokens = [], num_params = 0, params = None, func = None):
        self.b_type = b_type
        self.tokens = tokens
        self.num_params = len(params) if params is not None else num_params
        self.params = params
        self.func = func

class BuiltInFunctions:
    @staticmethod
    def highlight_code(siter, args):
        if len(args) == 1:
            lang = 'text'
            code = args[0]
            lines = []
        elif len(args) == 2:
            lang = args[0]
            code = args[1]
            lines = []
        elif len(args) == 3:
            lang = args[0]
            code = args[2]
            lines = args[1].split()
        else:
            Siter.warning('s.code takes 1-3 args, got {}'.format(len(args)))
            return ''

        def clean_code(code):
            # Replace < and > with HTML entities
            code = code.replace('<', '&lt;')
            code = code.replace('>', '&gt;')
            return code

        if code.find('\n') == -1:
            # This is a one-liner
            code = '<code>{}</code>'.format(clean_code(code))
        else:
            # This is a code block
            div_class = 'siter_code'

            if siter.Pygments:
                lexer = siter.PygmentsLexers.get_lexer_by_name(lang.lower())
                formatter = siter.PygmentsFormatters.HtmlFormatter(
                    linenos = True, cssclass = div_class, hl_lines=lines)
                code = siter.Pygments.highlight(code, lexer, formatter)
            else:
                code = '<div class="{}"><pre>{}</pre></div>' \
                    .format(div_class, clean_code(code))

        return code

class Siter:
    @staticmethod
    def error(e):
        raise RuntimeError('Siter runtime error\n{}'.format(e))

    @staticmethod
    def warning(w):
        print('[  Warning!  ] {}'.format(w))

    @staticmethod
    def info(m):
        print('[    Info    ] {}'.format(m))

    def __init__(self, arg):
        # Whether to re-generate up-to-date files
        self.ForceWrite = arg == 'force'

        # Block delimiters
        self.TagOpen = '{'
        self.TagClose = '}'

        # Marks the beginning of page content
        self.Marker = '~~~'

        self.dirs = Dirs()
        self.files = Files(self.dirs)

        os.makedirs(self.dirs.out_root.get_path(), exist_ok = True)

        # Copy site and template media files
        self.dirs.media.copy_to(self.dirs.out_media)
        self.dirs.template_media.copy_to(self.dirs.out_template_media)

        if self.files.marker.get_line(0):
            self.Marker = self.files.marker.get_line(0)

        if self.files.tags.get_line(0) and self.files.tags.get_line(1):
            self.TagOpen = self.files.tags.get_line(0)
            self.TagClose = self.files.tags.get_line(1)

            Siter.info('Using {} and {} as block tags'
                .format(self.TagOpen, self.TagClose))

        # Global function and variable bindings
        self.bindings = {}
        self.set_file_bindings(self.bindings, self.files.defs.get_path())

        def try_import(module):
            try:
                return importlib.import_module(module)
            except ImportError:
                return None

        self.Md = try_import('markdown')
        self.Pygments = try_import('pygments')
        self.PygmentsLexers = try_import('pygments.lexers')
        self.PygmentsFormatters = try_import('pygments.formatters')

    def make_flat_tokens(self, text):
        start = 0
        index = 0
        flat_tokens = []
        current_type = TokenType.Text

        while index < len(text):
            c = text[index]

            # TODO: remove unescaped '\' chars
            if c == '\\':
                index += 2
                start = index
                continue
            else:
                index += 1

            previous_type = current_type

            if c == '\n':
                current_type = TokenType.Newline
            elif c == ' ' or c == '\t':
                current_type = TokenType.Whitespace
            else:
                current_type = TokenType.Text

            found_delim = False

            for delim_token_type, delim_text in [(TokenType.TagOpen, self.TagOpen), (TokenType.TagClose, self.TagClose)]:
                delim_start = index - len(delim_text)

                if delim_start < start:
                    continue

                if text[delim_start : index] == delim_text:
                    if start < delim_start:
                        flat_tokens.append(Token(previous_type, text[start : delim_start]))

                    flat_tokens.append(Token(delim_token_type, text[delim_start : index]))

                    start = index
                    found_delim = True
                    break

            if not found_delim and previous_type is not current_type:
                if start < index - 1:
                    flat_tokens.append(Token(previous_type, text[start : index - 1]))
                    start = index - 1

        if start < index:
            flat_tokens.append(Token(current_type, text[start : index]))

        return flat_tokens

    def make_block_tokens(self, flat_tokens):
        stack = []
        block_tokens = []

        for token in flat_tokens:
            if token.t_type is TokenType.TagOpen:
                stack.append(Token(TokenType.Block))
            else:
                if token.t_type is TokenType.TagClose:
                    if len(stack) == 0:
                        Siter.error("Found extra closing tag")

                    token = stack.pop()

                if len(stack) > 0:
                    stack[-1].tokens.append(token)
                else:
                    block_tokens.append(token)

        if len(stack) > 0:
            Siter.error("Missing closing tag")

        return block_tokens

    def tokenize(self, text):
        flat_tokens = self.make_flat_tokens(text)
        return self.make_block_tokens(flat_tokens)

    def evaluate_tokens(self, tokens, bindings):
        eval_tokens = []

        for token in tokens:
            if token.t_type is not TokenType.Block:
                eval_tokens.append(token)
                continue

            if not token.is_call():
                # This block does not call a binding
                eval_tokens += self.evaluate_tokens(token.tokens, bindings)
                continue

            name = token.capture_call().resolve()[1:]

            if name not in bindings:
                # Name is unknown, discard block
                continue

            binding = bindings[name]
            temp_tokens = []

            if binding.b_type == BindingType.Variable:
                temp_tokens += self.evaluate_tokens(binding.tokens, bindings)
            elif binding.b_type == BindingType.Macro:
                args = token.capture_args()

                if len(args) != binding.num_params:
                    Siter.warning('Macro {} takes {} args, got {}'
                        .format(name, binding.num_params, len(args)))
                    continue

                arguments = []

                # Evaluate each argument
                for arg in args:
                    arg = self.evaluate_tokens([arg], bindings)
                    arguments.append(arg)

                bindings2 = bindings.copy()

                # Bind each parameter to the supplied argument
                for (i, param) in enumerate(binding.params):
                    bindings2[param.resolve()] = Binding(BindingType.Variable, tokens = arguments[i])

                temp_tokens += self.evaluate_tokens(binding.tokens, bindings2)
            elif binding.b_type == BindingType.Function:
                args = token.capture_args()

                if len(args) != binding.num_params:
                    Siter.warning('Function {} takes {} args, got {}'
                        .format(name, binding.num_params, len(args)))
                    continue

                arguments = []

                # Evaluate each argument
                for arg in args:
                    arg_s = ''
                    arg = self.evaluate_tokens([arg], bindings)

                    for t in arg:
                        arg_s += t.resolve()

                    arguments.append(arg_s)

                body = binding.func(self, arguments)
                temp_tokens += self.tokenize(body)
            else:
                Siter.error('Unknown binding type')

            # Trim leading and trailing whitespace
            start = 0
            end = len(temp_tokens)

            for t in temp_tokens:
                if t.t_type is TokenType.Text:
                    break
                else:
                    start += 1

            for t in reversed(temp_tokens):
                if t.t_type is TokenType.Text:
                    break
                else:
                    end -= 1

            eval_tokens += temp_tokens[start : end]

        return eval_tokens

    def set_file_bindings(self, bindings, read_file):
        try:
            with open(read_file, 'rU') as f:
                text = f.read()
        except FileNotFoundError:
            return {}

        start = 0
        marker = text.find(self.Marker)

        if marker != -1:
            bindings['s.content'] = Binding(
                BindingType.Variable,
                tokens = self.tokenize(text[marker + len(self.Marker) :]))
            text = text[: marker]

        for b in [t for t in self.tokenize(text) if t.t_type is TokenType.Block]:
            if b.is_variable():
                name, body = b.capture_variable()
                bindings[name.resolve()] = Binding(BindingType.Variable, tokens = body)
            elif b.is_macro():
                name, args, body = b.capture_macro()
                bindings[name.resolve()] = Binding(BindingType.Macro, params = args, tokens = body)
            else:
                Siter.error('Cannot parse block:\n{}'.format(b.resolve()))

    def set_builtin_bindings(self, bindings, read_file, subdir):
        bindings['s.if'] = Binding(
            BindingType.Function,
            num_params = 2,
            func = lambda _, args: args[1] if args[0] in bindings else '')

        bindings['s.ifnot'] = Binding(
            BindingType.Function,
            num_params = 2,
            func = lambda _, args: '' if args[0] in bindings else args[1])

        bindings['s.modified'] = Binding(
            BindingType.Function,
            num_params = 1,
            func = lambda _, args: time.strftime(
                args[0], time.localtime(os.stat(read_file).st_mtime)))

        bindings['s.generated'] = Binding(
            BindingType.Function,
            num_params = 1,
            func = lambda _, args: time.strftime(args[0]))

        bindings['s.code'] = Binding(
            BindingType.Function,
            num_params = -1,
            func = BuiltInFunctions.highlight_code)

        here = os.path.join(self.dirs.out_root.get_path(), subdir)
        rel_root_path = os.path.relpath(self.dirs.out_root.get_path(), here)
        rel_media_path = os.path.relpath(self.dirs.out_media.get_path(), here)

        bindings['s.root'] = Binding(
            BindingType.Variable,
            tokens = self.tokenize(rel_root_path))

        bindings['s.media'] = Binding(
            BindingType.Variable,
            tokens = self.tokenize(rel_media_path))

    def apply_template(self, template_file, bindings, subdir):
        output = ''
        tokens = self.tokenize(template_file.get_content())
        tokens = self.evaluate_tokens(tokens, bindings)

        for token in tokens:
            output += token.resolve()

        return output

    def up_to_date(self, read_file, write_file):
        if not self.ForceWrite and os.path.isfile(write_file):
            read_date = os.stat(read_file).st_mtime
            write_date = os.stat(write_file).st_mtime

            return read_date < write_date
        else:
            return False

    def run(self, subdir):
        in_path = os.path.join(self.dirs.pages.get_path(), subdir)
        out_path = os.path.join(self.dirs.out_root.get_path(), subdir)

        os.makedirs(out_path, exist_ok = True)

        for page in sorted(os.listdir(in_path)):
            read_file = os.path.join(in_path, page)
            write_file = os.path.join(out_path, page)

            if os.path.isdir(read_file):
                self.run(os.path.join(subdir, page))
                continue

            if self.up_to_date(read_file, write_file):
                print('[ Up to date ] {}'.format(write_file))
                continue

            print('[  Updating  ] {}'.format(write_file))

            bindings = self.bindings.copy()
            self.set_file_bindings(bindings, read_file)
            self.set_builtin_bindings(bindings, read_file, subdir)

            # Load template and replace variables and functions with bindings
            final = self.apply_template(self.files.page_html, bindings, subdir)

            with open(write_file, 'w') as f:
                f.write(final)

if __name__ == '__main__':
    siter = Siter(sys.argv[1] if len(sys.argv) > 1 else None)
    siter.run('')

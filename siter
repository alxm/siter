#!/usr/bin/env python3

"""
    Copyright 2011 Alex Margarit

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""

import sys
import os
import enum
import time
import importlib

class FileMode(enum.Enum):
    Optional = 0
    Create = 1
    Required = 2

class File:
    def __init__(self, path, mode):
        if mode is FileMode.Required and not os.path.exists(path):
            Siter.error('Required file {} not found'.format(path))

        self.path = path
        self.mode = mode

    def get_path(self):
        return self.path

class Dir(File):
    def __init__(self, path, mode):
        File.__init__(self, path, mode)

        if mode is FileMode.Create:
            os.makedirs(self.path, exist_ok = True)

    def add_file(self, name, mode):
        path = os.path.join(self.path, name)
        return TextFile(path, mode)

    def copy_to(self, dst_dir):
        src = self.path + '/'
        dst = dst_dir.path

        Siter.info('Copying media from {} to {}'.format(src, dst))
        os.system('rsync -r --delete {} {}'.format(src, dst))

class TextFile(File):
    def __init__(self, path, mode):
        File.__init__(self, path, mode)

        self.content = None
        self.lines = []

        try:
            with open(self.path, 'rU') as f:
                self.content = f.read()
                self.lines = self.content.splitlines()
        except FileNotFoundError:
            if self.mode is not FileMode.Optional:
                Siter.error('Required file {} not found'.format(self.path))

    def test_line(self, number, min_len = -1, max_len = -1):
        if self.content is None and self.mode is FileMode.Optional:
            return False

        error = None
        line = self.get_line(number)

        if line is None:
            error = '{}:{} line is missing'.format(self.path, number + 1)
        else:
            if min_len != -1 and len(line) < min_len:
                error = '{}:{} length must be at least {}, is {}: "{}"' \
                    .format(self.path, number + 1, min_len, len(line), line)
            elif max_len != -1 and len(line) > max_len:
                error = '{}:{} length must not exceed {}, is {}: "{}"' \
                    .format(self.path, number + 1, max_len, len(line), line)

        if error:
            if self.mode is FileMode.Optional:
                Siter.warning(error)
            else:
                Siter.error(error)

            return False

        return True

    def get_line(self, number):
        if number < len(self.lines):
            return self.lines[number].strip()

        return None

    def get_content(self):
        return self.content

class Dirs:
    def __init__(self):
        self.config = Dir('siter-config', FileMode.Optional)
        self.media = Dir('siter-media', FileMode.Optional)
        self.pages = Dir('siter-pages', FileMode.Required)
        self.template = Dir('siter-template', FileMode.Required)
        self.template_media = Dir('siter-template/media', FileMode.Optional)

        self.out_root = Dir('siter-out', FileMode.Create)
        self.out_media = Dir('siter-out/media', FileMode.Create)
        self.out_template_media = Dir('siter-out/media/template-media', FileMode.Create)

class Files:
    def __init__(self, dirs):
        self.defs = dirs.config.add_file('defs', FileMode.Optional)
        self.marker = dirs.config.add_file('marker', FileMode.Optional)
        self.tags = dirs.config.add_file('tags', FileMode.Optional)
        self.page_html = dirs.template.add_file('page.html', FileMode.Required)

class TokenType(enum.Enum):
    Rest = 0
    Text = 1
    Newline = 2
    Whitespace = 3
    TagOpen = 4
    TagClose = 5
    Block = 6

class Token:
    def __init__(self, t_type, text = None, tokens = None):
        self.t_type = t_type
        self.text = text
        self.tokens = tokens if tokens else []

    def resolve(self):
        if self.t_type is TokenType.Block:
            output = ''.join([t.resolve() for t in self.tokens])
            return '{' + output + '}'
        else:
            return self.text

    def capture(self, *args):
        i = 0
        results = []

        for arg in args:
            if arg is TokenType.Rest:
                results.append(self.tokens[i:])
                break

            found = False

            while i < len(self.tokens):
                token = self.tokens[i]
                i += 1

                if token.t_type is arg:
                    found = True
                    results.append(token)
                    break

                if (token.t_type is not TokenType.Newline and
                    token.t_type is not TokenType.Whitespace):
                    break

            if not found:
                return None

        return results

    def is_variable(self):
        return self.capture(TokenType.Text)[0].resolve() == 'var'

    def capture_variable(self):
        # {var name *}
        results = self.capture(TokenType.Text, TokenType.Text, TokenType.Rest)

        name = results[1]
        body = results[2]

        return name, body

    def is_macro(self):
        return self.capture(TokenType.Text)[0].resolve() == 'fun'

    def capture_macro(self):
        # {fun name {args} body}
        results = self.capture(TokenType.Text,
                               TokenType.Text,
                               TokenType.Block,
                               TokenType.Rest)

        name = results[1]
        args = [t for t in results[2].tokens if t.t_type is TokenType.Text]
        body = results[3]

        return name, args, body

    def is_call(self):
        results = self.capture(TokenType.Text)

        if results:
            name = results[0].resolve()
            return len(name) > 1 and name[0] == '`'

        return False

    def capture_call(self):
        # {name *}
        return self.capture(TokenType.Text)[0]

    def capture_args(self):
        # {name {arg1} {arg2} *}
        results = self.capture(TokenType.Text, TokenType.Rest)

        if len(results) < 2:
            Siter.error('No arguments for {}'.format(results[0].resolve()))

        args = [t for t in results[1] if t.t_type is TokenType.Block]

        if len(args) == 0:
            return [Token(TokenType.Block, tokens = results[1])]

        return args

class BindingType(enum.Enum):
    Variable = 0
    Macro = 1
    Function = 2

class Binding:
    def __init__(self, b_type, tokens = None, num_params = 0, params = None, func = None):
        self.b_type = b_type
        self.tokens = tokens
        self.num_params = len(params) if params else num_params
        self.params = params
        self.func = func

class BuiltInFunctions:
    @staticmethod
    def highlight_code(siter, args):
        if len(args) == 1:
            lang = 'text'
            code = args[0]
            lines = []
        elif len(args) == 2:
            lang = args[0]
            code = args[1]
            lines = []
        elif len(args) == 3:
            lang = args[0]
            code = args[2]
            lines = args[1].split()
        else:
            Siter.warning('s.code takes 1-3 args, got {}'.format(len(args)))
            return ''

        def clean_code(code):
            # Replace < and > with HTML entities
            code = code.replace('<', '&lt;')
            code = code.replace('>', '&gt;')
            return code

        if code.find('\n') == -1:
            # This is a one-liner
            code = '<code>{}</code>'.format(clean_code(code))
        else:
            # This is a code block
            div_class = 'siter_code'

            if siter.Pygments:
                lexer = siter.PygmentsLexers.get_lexer_by_name(lang.lower())
                formatter = siter.PygmentsFormatters.HtmlFormatter(
                    linenos = True, cssclass = div_class, hl_lines=lines)
                code = siter.Pygments.highlight(code, lexer, formatter)
            else:
                code = '<div class="{}"><pre>{}</pre></div>' \
                    .format(div_class, clean_code(code))

        return code

class Siter:
    @staticmethod
    def message(title, content, color = 2):
        space = max(2, 12 - len(title))
        head = '■' * (space // 2)
        tail = '■' * (space - space // 2)

        print('\033[{};1m{} {} {}\033[0m {}'
            .format(30 + color, head, title, tail, content))

    @staticmethod
    def error(e):
        Siter.message('Error', e, 1)
        raise RuntimeError('Siter')

    @staticmethod
    def warning(w):
        Siter.message('Warning', w, 3)

    @staticmethod
    def info(m):
        Siter.message('Info', m, 4)

    def __init__(self, argv):
        # Whether to re-generate up-to-date files
        self.ForceWrite = False

        for arg in argv:
            if arg == '-f' or arg == '--force':
                self.ForceWrite = True

        # Block delimiters
        self.TagOpen = '{'
        self.TagClose = '}'

        # Marks the beginning of page content
        self.Marker = '~~~'

        # Declare and optionally create the dirs and files Siter uses
        self.dirs = Dirs()
        self.files = Files(self.dirs)

        # Copy site and template media files
        self.dirs.media.copy_to(self.dirs.out_media)
        self.dirs.template_media.copy_to(self.dirs.out_template_media)

        if self.files.marker.test_line(0, 1):
            self.Marker = self.files.marker.get_line(0)

        if self.files.tags.test_line(0, 1) and self.files.tags.test_line(1, 1):
            self.TagOpen = self.files.tags.get_line(0)
            self.TagClose = self.files.tags.get_line(1)

            Siter.info('Using {} and {} as block tags'
                .format(self.TagOpen, self.TagClose))

        # Global function and variable bindings
        self.bindings = {}
        self.set_file_bindings(self.bindings, self.files.defs.get_path())

        def try_import(module):
            try:
                return importlib.import_module(module)
            except ImportError:
                return None

        self.Md = try_import('markdown')
        self.Pygments = try_import('pygments')
        self.PygmentsLexers = try_import('pygments.lexers')
        self.PygmentsFormatters = try_import('pygments.formatters')

    def make_flat_tokens(self, text):
        flat_tokens = []
        current_type = None
        escaped = False
        escaped_index = -1
        token = ''

        for c in text:
            if c == '\\' and not escaped:
                escaped = True
                continue

            previous_type = current_type

            if c == '\n':
                current_type = TokenType.Newline
            elif c == ' ' or c == '\t':
                current_type = TokenType.Whitespace
            else:
                current_type = TokenType.Text

            if current_type is previous_type:
                token += c
            else:
                if len(token) > 0:
                    flat_tokens.append(Token(previous_type, token))

                token = c
                escaped_index = -1

            if escaped:
                escaped = False
                escaped_index = len(token) - 1

            for delim_type, delim in [(TokenType.TagOpen, self.TagOpen),
                                      (TokenType.TagClose, self.TagClose)]:
                if len(token) - escaped_index <= len(delim):
                    continue

                if token[-len(delim) :] != delim:
                    continue

                if len(token) > len(delim):
                    flat_tokens.append(
                        Token(TokenType.Text, token[: -len(delim)]))

                flat_tokens.append(Token(delim_type, token[-len(delim) :]))
                token = ''
                escaped_index = -1
                break

        if len(token) > 0:
            flat_tokens.append(Token(current_type, token))

        return flat_tokens

    def make_block_tokens(self, flat_tokens):
        stack = []
        block_tokens = []

        for token in flat_tokens:
            if token.t_type is TokenType.TagOpen:
                # Subsequent tokens will be added to this new block
                stack.append(Token(TokenType.Block))
            else:
                if token.t_type is TokenType.TagClose:
                    if len(stack) == 0:
                        Siter.error("Found extra closing tag")

                    # Got the closing tag, pop the block from the stack
                    token = stack.pop()

                if len(stack) > 0:
                    stack[-1].tokens.append(token)
                else:
                    block_tokens.append(token)

        if len(stack) > 0:
            Siter.error("Missing closing tag")

        return block_tokens

    def tokenize(self, text):
        flat_tokens = self.make_flat_tokens(text)
        return self.make_block_tokens(flat_tokens)

    def evaluate_tokens(self, tokens, bindings):
        eval_tokens = []

        for token in tokens:
            if token.t_type is not TokenType.Block:
                eval_tokens.append(token)
                continue

            if not token.is_call():
                # This block does not call a binding
                eval_tokens += self.evaluate_tokens(token.tokens, bindings)
                continue

            # Get the binding's name and skip the `
            name = token.capture_call().resolve()[1:]

            if name not in bindings:
                # Name is unknown, discard block
                continue

            binding = bindings[name]
            temp_tokens = []

            if binding.b_type == BindingType.Variable:
                body_tokens = self.evaluate_tokens(binding.tokens, bindings)

                # Run page content through Markdown
                if name == 's.content' and self.Md:
                    content = ''.join([t.resolve() for t in body_tokens])
                    md = self.Md.markdown(content, output_format = 'html5')
                    body_tokens = [Token(TokenType.Text, text = md)]

                temp_tokens += body_tokens
            elif binding.b_type == BindingType.Macro:
                args = token.capture_args()

                if len(args) != binding.num_params:
                    Siter.warning('Macro {} takes {} args, got {}'
                        .format(name, binding.num_params, len(args)))
                    continue

                arguments = []

                # Evaluate each argument
                for arg in args:
                    arg = self.evaluate_tokens([arg], bindings)
                    arguments.append(arg)

                bindings2 = bindings.copy()

                # Bind each parameter to the supplied argument
                for (i, param) in enumerate(binding.params):
                    bindings2[param.resolve()] = Binding(BindingType.Variable,
                                                         tokens = arguments[i])

                temp_tokens += self.evaluate_tokens(binding.tokens, bindings2)
            elif binding.b_type == BindingType.Function:
                args = token.capture_args()

                if len(args) != binding.num_params != -1:
                    Siter.warning('Function {} takes {} args, got {}'
                        .format(name, binding.num_params, len(args)))
                    continue

                arguments = []

                # Evaluate each argument
                for arg in args:
                    arg = self.evaluate_tokens([arg], bindings)
                    arguments.append(''.join([t.resolve() for t in arg]))

                body = binding.func(self, arguments)
                temp_tokens += self.tokenize(body)
            else:
                Siter.error('Unknown binding type')

            # Trim leading and trailing whitespace
            start = 0
            end = len(temp_tokens)

            for t in temp_tokens:
                if t.t_type is TokenType.Text:
                    break
                else:
                    start += 1

            for t in reversed(temp_tokens):
                if t.t_type is TokenType.Text:
                    break
                else:
                    end -= 1

            eval_tokens += temp_tokens[start : end]

        return eval_tokens

    def set_file_bindings(self, bindings, read_file):
        try:
            with open(read_file, 'rU') as f:
                text = f.read()
        except FileNotFoundError:
            return {}

        start = 0
        marker = text.find(self.Marker)

        if marker != -1:
            # s.content is everything after the first marker occurence
            bindings['s.content'] = Binding(
                BindingType.Variable,
                tokens = self.tokenize(text[marker + len(self.Marker) :]))
            text = text[: marker]

        for b in [t for t in self.tokenize(text) if t.t_type is TokenType.Block]:
            if b.is_variable():
                name, body = b.capture_variable()
                bindings[name.resolve()] = Binding(BindingType.Variable,
                                                   tokens = body)
            elif b.is_macro():
                name, args, body = b.capture_macro()
                bindings[name.resolve()] = Binding(BindingType.Macro,
                                                   params = args,
                                                   tokens = body)
            else:
                Siter.error('Cannot parse block:\n{}'.format(b.resolve()))

    def set_builtin_bindings(self, bindings, read_file, subdir):
        bindings['s.if'] = Binding(
            BindingType.Function,
            num_params = 2,
            func = lambda _, args: args[1] if args[0] in bindings else '')

        bindings['s.ifnot'] = Binding(
            BindingType.Function,
            num_params = 2,
            func = lambda _, args: '' if args[0] in bindings else args[1])

        bindings['s.modified'] = Binding(
            BindingType.Function,
            num_params = 1,
            func = lambda _, args: time.strftime(
                args[0], time.localtime(os.stat(read_file).st_mtime)))

        bindings['s.generated'] = Binding(
            BindingType.Function,
            num_params = 1,
            func = lambda _, args: time.strftime(args[0]))

        bindings['s.code'] = Binding(
            BindingType.Function,
            num_params = -1,
            func = BuiltInFunctions.highlight_code)

        here = os.path.join(self.dirs.out_root.get_path(), subdir)
        rel_root_path = os.path.relpath(self.dirs.out_root.get_path(), here)
        rel_media_path = os.path.relpath(self.dirs.out_media.get_path(), here)

        bindings['s.root'] = Binding(
            BindingType.Variable,
            tokens = self.tokenize(rel_root_path))

        bindings['s.media'] = Binding(
            BindingType.Variable,
            tokens = self.tokenize(rel_media_path))

    def apply_template(self, template_file, bindings, subdir):
        tokens = self.tokenize(template_file.get_content())
        tokens = self.evaluate_tokens(tokens, bindings)

        return ''.join([t.resolve() for t in tokens])

    def up_to_date(self, read_file, write_file):
        if not self.ForceWrite and os.path.isfile(write_file):
            read_date = os.stat(read_file).st_mtime
            write_date = os.stat(write_file).st_mtime

            return read_date < write_date
        else:
            return False

    def run(self, subdir):
        in_path = os.path.join(self.dirs.pages.get_path(), subdir)
        out_path = os.path.join(self.dirs.out_root.get_path(), subdir)

        os.makedirs(out_path, exist_ok = True)

        for page in sorted(os.listdir(in_path)):
            read_file = os.path.join(in_path, page)
            write_file = os.path.join(out_path, page)

            if os.path.isdir(read_file):
                self.run(os.path.join(subdir, page))
                continue

            if self.up_to_date(read_file, write_file):
                Siter.message('Up to date', write_file)
                continue

            Siter.message('Updating', write_file)

            #   global bindings from the defs file
            # + bindings declared by the current page file
            # + siter built-in bindings
            bindings = self.bindings.copy()
            self.set_file_bindings(bindings, read_file)
            self.set_builtin_bindings(bindings, read_file, subdir)

            # Load template and replace variables and functions with bindings
            final = self.apply_template(self.files.page_html, bindings, subdir)

            with open(write_file, 'w') as f:
                f.write(final)

if __name__ == '__main__':
    siter = Siter(sys.argv)
    siter.run('')

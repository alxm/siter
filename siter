#!/usr/bin/python

"""
    Copyright 2011 Alex Margarit

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""

import os, re, sys, time

class Block:
    def __init__(self, index, text):
        self.index = index
        self.whole = text
        self.contents = text[2 : -2].strip()

        match = re.match("(\w+)\s*(.*)$", self.contents, re.DOTALL)

        if match:
            self.name = match.group(1)
            self.args = match.group(2)
        else:
            self.name = None
            self.args = None

    def get_call(self, bindings):
        return (self.name, self.args) if self.name in bindings else None

    @staticmethod
    def get_all(text):
        blocks = []
        start = 0

        while True:
            index = text.find("{{", start)

            if index == -1:
                break

            count = 1

            last_open = False
            last_close = False

            for i in range(index + 2, len(text)):
                if text[i] == "{":
                    if last_open:
                        count += 1
                        last_open = False
                    else:
                        last_open = True
                else:
                    last_open = False

                if text[i] == "}":
                    if last_close:
                        count -= 1
                        last_close = False
                    else:
                        last_close = True
                else:
                    last_close = False

                if count == 0:
                    start = i + 1
                    blocks.append(Block(index, text[index : start]))
                    break

            if count != 0:
                break

        return blocks

class Siter:
    def __init__(self, arg):
        self.arg_force = arg == "force"

        self.pages_dir = "siter-pages/"
        self.posts_dir = "siter-posts/"
        self.template_dir = "siter-template/"

        for d in [self.pages_dir, self.template_dir]:
            if not os.path.isdir(d):
                self.error("Can't find dir " + d)

        self.bindings = {}
        self.posts = []

    def error(self, error):
        print "[   Error!   ] " + error
        sys.exit(1)

    def evaluate(self, text, bindings):
        for block in Block.get_all(text):
            call = block.get_call(bindings)

            if not call:
                continue

            (name, args) = call
            (params, body, handler) = bindings[name]

            bindings2 = dict(bindings)
            del bindings2[name]

            if handler or len(params) > 0:
                arg = ""
                arguments = []

                args = self.evaluate(args, bindings2).split("\n")
                args = [a.strip() for a in args]

                for a in args:
                    if a[-1] == "\\":
                        arg += a[: -1]
                    else:
                        arguments.append(arg + a)
                        arg = ""

                if len(arguments) != len(params):
                    self.error("Wrong number of arguments: {0} instead of {1}\n{2}"
                            .format(len(arguments), len(params), block.whole))

                if handler:
                    body = handler(arguments)
                else:
                    for i in range(len(arguments)):
                        for m in re.finditer("\{\{\s*" + params[i] + "\s*\}\}", body, re.DOTALL):
                            body = body.replace(m.group(), arguments[i], 1)

            body = self.evaluate(body, bindings2).replace("\n", "")
            text = text.replace(block.whole, body, 1)

        return text

    def get_bindings(self, read_file):
        re_asg = re.compile("(.*)=\s*$", re.DOTALL)
        re_var = re.compile("(\w+)$", re.DOTALL)
        re_fun = re.compile("(\w+)\s+(.*)$", re.DOTALL)

        with open(read_file, "rU") as f:
            text = f.read()

        start = 0
        bindings = {}

        for block in Block.get_all(text):
            asg = re_asg.match(text[start : block.index].strip())

            if not asg:
                self.error("Missing assignment\n"
                    + text[start : block.index + len(block.whole)].strip())

            lhs = asg.group(1).strip()
            var = re_var.match(lhs)
            fun = re_fun.match(lhs)

            if var:
                name = var.group(1)
                bindings[name] = ([], block.contents, None)
            elif fun:
                name = fun.group(1)
                params = [p for p in re.split("\s+", fun.group(2).strip())]
                bindings[name] = (params, block.contents, None)
            else:
                self.error("Assignment syntax error\n" + lhs)

            start = block.index + len(block.whole)

        return bindings

    def apply_template(self, name, bindings):
        template_file = self.template_dir + name

        if not os.path.isfile(template_file):
            return None

        with open(template_file, "rU") as f:
            template = f.read()

        template = template.replace('="./', '="siter-template/')

        return self.evaluate(template, bindings)

    def up_to_date(self, read_file, write_file):
        if not self.arg_force and os.path.isfile(write_file):
            read_date = os.stat(read_file).st_mtime
            write_date = os.stat(write_file).st_mtime

            return read_date < write_date
        else:
            return False

    def run_posts(self):
        if not os.path.isdir(self.posts_dir):
            return

        posts = os.listdir(self.posts_dir)
        posts.sort(key = lambda p: p)
        posts.reverse()

        for p in posts:
            read_file = self.posts_dir + p
            write_file = p

            bindings = self.get_bindings(read_file)
            bindings["siter_post_link"] = ([], write_file, None)
            bindings["siter_modified"] = ([], time.strftime("%a, %d %b %Y"), None)

            self.posts.append(bindings)

            if self.up_to_date(read_file, write_file):
                print "[ Up to date ] " + write_file
                continue

            print "[  Updating  ] " + write_file

            page = self.apply_template("post.html", bindings)

            if page:
                with open(write_file, "w") as f:
                    f.write(page)
            else:
                self.error("Can't find post template")

        def single_post(args):
            try:
                p = int(args[0])
            except ValueError:
                self.error("single_post: Bad argument")

            post = self.apply_template("post-full.html", self.posts[p])

            if not post:
                self.error("Can't find full post template")

            return post

        def posts_list(args):
            try:
                start = int(args[0])
            except ValueError:
                self.error("posts_list: Bad argument")

            posts = ""

            for p in self.posts[start :]:
                post = self.apply_template("post-stub.html", p)

                if post:
                    posts = posts + "<li>" + post + "</li>"
                else:
                    self.error("Can't find post stub template")

            posts = '<ul class="siter_posts_list">' + posts + '</ul>'

            return posts

        self.bindings["siter_post"] = ([None], None, single_post)
        self.bindings["siter_posts"] = ([None], None, posts_list)

    def run_pages(self):
        pages = os.listdir(self.pages_dir)
        pages.sort(key = lambda p: p)

        for p in pages:
            read_file = self.pages_dir + p
            write_file = p

            if self.up_to_date(read_file, write_file):
                print "[ Up to date ] " + write_file
                continue

            print "[  Updating  ] " + write_file

            bindings = dict(self.bindings, **self.get_bindings(read_file))
            bindings["siter_modified"] = ([], time.strftime("%a, %d %b %Y"), None)

            page = self.apply_template("page.html", bindings)

            if page:
                with open(write_file, "w") as f:
                    f.write(page)
            else:
                self.error("Can't find page template")

if __name__ == "__main__":
    siter = Siter(sys.argv[1] if len(sys.argv) > 1 else None)
    siter.run_posts()
    siter.run_pages()

#!/usr/bin/env python3

"""
    Copyright 2011 Alex Margarit

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""

import os, re, sys, shutil, time

class Settings:
    # Whether to re-generate up-to-date files
    FORCE = False

    # Block delimiters
    TAG_OPEN = "{"
    TAG_CLOSE = "}"
    TAG_OPEN_ESC = re.escape(TAG_OPEN)
    TAG_CLOSE_ESC = re.escape(TAG_CLOSE)

    # Marks the beginning of page content
    MARKER = "~~~"

    # Where generated pages are written
    OUTDIR = "siter-out"

    # Subdir in siter-out for media content copied from siter-media
    MEDIADIR = "media"

class Block:
    def __init__(self, siter, text):
        # Block including { and }
        self.whole = text

        # Just the inside of { ... }
        self.content = text[len(siter.settings.TAG_OPEN) : -len(siter.settings.TAG_CLOSE)].strip()

class Binding:
    def __init__(self, params = None, body = None, func = None):
        self.params = params
        self.body = body
        self.func = func

        self.is_var = body is not None and params is None
        self.is_macro = body is not None and params is not None
        self.is_func = func is not None

class Siter:
    def __init__(self, arg):
        self.settings = Settings()

        if arg == "force":
            self.settings.FORCE = True

        # "label" -> (path, required)
        self.dirs = {
            "config": ("siter-config", False),
            "media": ("siter-media", False),
            "pages": ("siter-pages", True),
            "template": ("siter-template", True),
        }

        # "label" -> (path, required)
        self.files = {
            "defs": (self.getdir("config") + "/" + "defs", False),
            "marker": (self.getdir("config") + "/" + "marker", False),
            "media": (self.getdir("config") + "/" + "media", False),
            "outdir": (self.getdir("config") + "/" + "outdir", False),
            "tags": (self.getdir("config") + "/" + "tags", False),
            "template": (self.getdir("template") + "/" + "page.html", True),
        }

        for label, (path, required) in iter(self.dirs.items()):
            if required and not os.path.isdir(path):
                self.error("Can't find {0} dir".format(path))

        for label, (path, required) in iter(self.files.items()):
            if required and not os.path.isfile(path):
                self.error("Can't find {0} file".format(path))

        if os.path.isfile(self.getfile("outdir")):
            with open(self.getfile("outdir"), "rU") as f:
                out = f.readline().strip()

                if len(out) > 0:
                    self.settings.OUTDIR = out

        if not os.path.isdir(self.settings.OUTDIR):
            os.makedirs(self.settings.OUTDIR)

        if os.path.isfile(self.getfile("media")):
            with open(self.getfile("media"), "rU") as f:
                media = f.readline().strip()

                if len(media) > 0:
                    self.settings.MEDIADIR = media

        self.info("Output dir is {0}".format(self.settings.OUTDIR))

        # Copy media files
        os.system("rsync -r --delete {0} {1}".format(self.getdir("media") + "/", self.settings.OUTDIR + "/" + self.settings.MEDIADIR))

        if os.path.isfile(self.getfile("marker")):
            with open(self.getfile("marker"), "rU") as f:
                marker = f.readline().strip()

                if len(marker) > 0:
                    self.settings.MARKER = marker

        if os.path.isfile(self.getfile("tags")):
            with open(self.getfile("tags"), "rU") as f:
                tag_open = f.readline().strip()
                tag_close = f.readline().strip()

                if len(tag_open) == 0:
                    self.error("Custom open tag is an empty string")
                elif len(tag_close) == 0:
                    self.error("Custom close tag is an empty string")
                else:
                    self.info("Using {0} and {1} as tags".format(tag_open, tag_close))
                    self.settings.TAG_OPEN = tag_open
                    self.settings.TAG_CLOSE = tag_close
                    self.settings.TAG_OPEN_ESC = re.escape(tag_open)
                    self.settings.TAG_CLOSE_ESC = re.escape(tag_close)

        # Calling a function or variable: <name> <arguments>
        self.re_use = re.compile("([\w\.\-]+)\s*"
                                 + "(.*)"
                                 + "$",
                                 re.DOTALL)

        # Declaring a variable: <name> <contents>
        self.re_var = re.compile("([\w\.\-]+)\s*"
                                 + "(.*)"
                                 + "$",
                                 re.DOTALL)

        # Declaring a function: <name> {parameters} <body>
        self.re_fun = re.compile("([\w\.\-]+)\s*"
                                 + self.settings.TAG_OPEN_ESC
                                 + "(.*?)"
                                 + self.settings.TAG_CLOSE_ESC
                                 + "\s*"
                                 + "(.*)"
                                 + "$",
                                 re.DOTALL)

        # s.if <binding> <body>
        self.re_if = re.compile("s\.if\s+([\w\.\-]+)\s+"
                                + "(.*)"
                                + "$",
                                re.DOTALL)

        # s.ifnot <binding> <body>
        self.re_ifnot = re.compile("s\.ifnot\s+([\w\.\-]+)\s+"
                                   + "(.*)"
                                   + "$",
                                   re.DOTALL)

        # Global function and variable bindings
        self.bindings = self.get_bindings(self.getfile("defs"))

    def getdir(self, name):
        return self.dirs[name][0]

    def getfile(self, name):
        return self.files[name][0]

    def error(self, e):
        print("[   Error!   ] {0}".format(e))
        sys.exit(1)

    def warning(self, w):
        print("[  Warning!  ] {0}".format(w))

    def info(self, m):
        print("[    Info    ] {0}".format(m))

    def extract_blocks(self, text):
        # A block is a "{something}" that may contain other "{somethings}"
        blocks = []

        count = 0
        start = 0
        index = 0

        while index < len(text):
            index_open = text.find(self.settings.TAG_OPEN, index)
            index_close = text.find(self.settings.TAG_CLOSE, index)

            if index_open == -1 and index_close == -1:
                # No more tags found
                break

            if (index_open < index_close and index_open != -1) or index_close == -1:
                if count == 0:
                    # Current block starts here
                    start = index_open

                count += 1
                index = index_open + len(self.settings.TAG_OPEN)
            elif (index_close < index_open and index_close != -1) or index_open == -1:
                count -= 1
                index = index_close + len(self.settings.TAG_CLOSE)

            if count == 0:
                blocks.append(
                    Block(self, text[start : index_close + len(self.settings.TAG_CLOSE)])
                )

        return blocks

    def evaluate_text(self, text, bindings):
        for block in self.extract_blocks(text):
            ifso = self.re_if.match(block.content)
            ifnot = self.re_ifnot.match(block.content)
            use = self.re_use.match(block.content)

            if ifso:
                check = ifso.group(1)
                body = ifso.group(2)

                if check not in bindings:
                    # Conditional failed, discard the block
                    text = text.replace(block.whole, "", 1)
                    continue

                # Evaluate the conditional body, then replace the block with it
                body = self.evaluate_text(body, bindings)
                text = text.replace(block.whole, body, 1)
            elif ifnot:
                check = ifnot.group(1)
                body = ifnot.group(2)

                if check in bindings:
                    # Conditional failed, discard the block
                    text = text.replace(block.whole, "", 1)
                    continue

                # Evaluate the conditional body, then replace the block with it
                body = self.evaluate_text(body, bindings)
                text = text.replace(block.whole, body, 1)
            elif use:
                name = use.group(1)
                args = use.group(2)

                if name not in bindings:
                    # Name is unknown, discard the block
                    text = text.replace(block.whole, "", 1)
                    continue

                binding = bindings[name]

                # Avoid infinite recursion
                del bindings[name]

                if binding.is_var:
                    body = self.evaluate_text(binding.body, bindings)
                    text = text.replace(block.whole, body, 1)
                elif binding.is_macro or binding.is_func:
                    arg_blocks = self.extract_blocks(args)

                    if binding.is_macro and len(arg_blocks) != len(binding.params):
                        self.warning("Macro {0} expects {1} arguments, got {2}"
                            .format(name, len(binding.params), len(arg_blocks)))
                    elif binding.is_func and binding.params > 0 and len(arg_blocks) != binding.params:
                        self.warning("Function {0} expects {1} arguments, got {2}"
                            .format(name, binding.params, len(arg_blocks)))
                    else:
                        arguments = []

                        # Evaluate each argument
                        for arg_block in arg_blocks:
                            arg = self.evaluate_text(arg_block.content, bindings)
                            arguments.append(arg)

                        if binding.is_macro:
                            bindings2 = dict(bindings)

                            # Bind each parameter to the supplied argument
                            for (i, param) in enumerate(binding.params):
                                bindings2[param] = Binding(body = arguments[i])

                            body = self.evaluate_text(binding.body, bindings2)
                        elif binding.is_func:
                            body = binding.func(arguments)

                        text = text.replace(block.whole, body, 1)
                else:
                    self.error("Binding {0} is not a var/func/macro".format(name))

                # Restore binding
                bindings[name] = binding

        return text

    def get_bindings(self, read_file):
        if not os.path.isfile(read_file):
            return {}

        with open(read_file, "rU") as f:
            text = f.read()

        start = 0

        # "name" -> Binding object
        bindings = {}

        # Find the content-start marker
        marker = text.find(self.settings.MARKER)

        if marker != -1:
            bindings["s.content"] = Binding(body = text[marker + len(self.settings.MARKER) :].strip())
            text = text[: marker]

        for block in self.extract_blocks(text):
            var = self.re_var.match(block.content)
            fun = self.re_fun.match(block.content)

            if fun:
                name = fun.group(1)
                params = [p for p in re.split("\s+", fun.group(2).strip())]
                body = fun.group(3)
                bindings[name] = Binding(params = params, body = body)
            elif var:
                name = var.group(1)
                bindings[name] = Binding(body = var.group(2))
            else:
                self.error("Block is neither variable nor function\n{0}".format(block.whole))

        return bindings

    def apply_template(self, name, bindings, subdir):
        with open(self.getfile(name), "rU") as f:
            template = f.read()

        # This way links and media paths work in subdir pages too
        root_path = os.path.relpath(self.settings.OUTDIR, self.settings.OUTDIR + "/" + subdir)

        # Built-in bindings
        bindings["s.root"] = Binding(body = root_path)
        bindings["s.media"] = Binding(body = root_path + "/" + self.settings.MEDIADIR)

        # Fill in template
        template = self.evaluate_text(template, bindings)

        return template

    def up_to_date(self, read_file, write_file):
        if not self.settings.FORCE and os.path.isfile(write_file):
            read_date = os.stat(read_file).st_mtime
            write_date = os.stat(write_file).st_mtime

            return read_date < write_date
        else:
            return False

    def highlight_code(self, args):
        if len(args) == 1:
            lang = "text"
            code = args[0]
        elif len(args) == 2:
            lang = args[0]
            code = args[1]
        else:
            self.warning("s.code expects 1 or 2 arguments, got " + len(args))
            return ""

        code = code.strip()
        is_block = code.find("\n") != -1

        div_class = "siter_code"
        container_class = "siter_code_block" if is_block else "siter_code_line"

        try:
            import pygments, pygments.formatters, pygments.lexers
        except ImportError:
            # Replace < and > with HTML entities
            code = code.replace("<", "&lt;")
            code = code.replace(">", "&gt;")
            code = '<div class="' + div_class + '"><pre>' + code + '</pre></div>'
        else:
            lexer = pygments.lexers.get_lexer_by_name(lang.lower().strip())
            formatter = pygments.formatters.HtmlFormatter(linenos = is_block, cssclass = div_class)
            code = pygments.highlight(code, lexer, formatter)

        return '<div class="' + container_class + '">' + code + '</div>'

    def run(self, subdir):
        pages = os.listdir(self.getdir("pages") + "/" + subdir)
        pages.sort(key = lambda p: p)

        for p in pages:
            read_file = self.getdir("pages") + "/" + subdir + "/" + p
            write_file = self.settings.OUTDIR + "/" + subdir + "/" + p

            if os.path.isdir(read_file):
                self.run(subdir + "/" + p)
                continue

            if self.up_to_date(read_file, write_file):
                print("[ Up to date ] " + write_file)
                continue

            print("[  Updating  ] " + write_file)

            # Go through page file and extract bindings
            bindings = dict(list(self.bindings.items()) + list(self.get_bindings(read_file).items()))

            # Built-in bindings
            bindings["s.modified"] = Binding(
                params = 1,
                func = lambda args: time.strftime(args[0], time.localtime(os.stat(read_file).st_mtime))
            )
            bindings["s.generated"] = Binding(
                params = 1,
                func = lambda args: time.strftime(args[0])
            )
            bindings["s.code"] = Binding(
                params = 0,
                func = self.highlight_code
            )

            # Load template and replace variables and functions with bindings
            page = self.apply_template("template", bindings, subdir)

            if not os.path.isdir(self.settings.OUTDIR + "/" + subdir):
                os.makedirs(self.settings.OUTDIR + "/" + subdir)

            with open(write_file, "w") as f:
                f.write(page)

if __name__ == "__main__":
    siter = Siter(sys.argv[1] if len(sys.argv) > 1 else None)
    siter.run(".")

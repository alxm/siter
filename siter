#!/usr/bin/env python3

"""
    Copyright 2011 Alex Margarit

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""

import os, re, sys, shutil, time

class File:
    def __init__(self, path, required = False):
        self.path = path
        self.required = required

        if self.required and not os.path.exists(self.path):
            Siter.error('Required file {} not found'.format(self.path))

class Dir(File):
    def add_file(self, name, required = False):
        path = os.path.join(self.path, name)
        return TextFile(path, required)

class TextFile(File):
    def __init__(self, path, required = False):
        File.__init__(self, path, required)

        self.lines = []
        self.content = ''

        try:
            with open(self.path, 'rU') as f:
                for line in f:
                    line = line.strip()
                    self.lines.append(line if len(line) > 0 else None)

                f.seek(0)
                self.content = f.read()
        except FileNotFoundError:
            if self.required:
                Siter.error('Required file {} not found'.format(self.path))

    def line(self, number):
        if number < len(self.lines):
            return self.lines[number]
        elif self.required:
            Siter.error('Missing required line {}:{}'.format(self.path, number))
        else:
            return None

class Dirs:
    def __init__(self):
        self.config = Dir('siter-config')
        self.media = Dir('siter-media')
        self.pages = Dir('siter-pages', True)
        self.template = Dir('siter-template', True)
        self.template_media = Dir('siter-template/media')

class Files:
    def __init__(self, dirs):
        self.defs = dirs.config.add_file('defs')
        self.marker = dirs.config.add_file('marker')
        self.media = dirs.config.add_file('media')
        self.outdir = dirs.config.add_file('outdir')
        self.tags = dirs.config.add_file('tags')
        self.page_html = dirs.template.add_file('page.html', True)

class Tag:
    def __init__(self, text):
        self.raw = text
        self.escaped = re.escape(text)
        self.length = len(text)

class Settings:
    def __init__(self, arg):
        # Whether to re-generate up-to-date files
        self.Force = arg == 'force'

        # Block delimiters
        self.TagOpen = Tag('{')
        self.TagClose = Tag('}')

        # Marks the beginning of page content
        self.Marker = '~~~'

        # Where generated pages are written
        self.OutDir = 'siter-out'

        # Subdir in siter-out for media content copied from siter-media
        self.MediaDir = 'media'

class Block:
    def __init__(self, siter, text):
        # Add block tags if missing
        if text.find(siter.settings.TagOpen.raw) != 0:
            text = siter.settings.TagOpen.raw + text + siter.settings.TagClose.raw

        # Block including { and }
        self.whole = text

        # Just the inside of { ... }
        self.content = text[siter.settings.TagOpen.length : -siter.settings.TagClose.length].strip()

class Binding:
    def __init__(self, params = None, body = None, func = None):
        if body is not None:
            body = body.strip()

        self.params = params
        self.body = body
        self.func = func

        self.is_var = body is not None and params is None
        self.is_macro = body is not None and params is not None
        self.is_func = func is not None

class Siter:
    @staticmethod
    def error(e):
        print('[   Error!   ] {}'.format(e))
        sys.exit(1)

    @staticmethod
    def warning(w):
        print('[  Warning!  ] {}'.format(w))

    @staticmethod
    def info(m):
        print('[    Info    ] {}'.format(m))

    def __init__(self, arg):
        self.settings = Settings(arg)
        self.dirs = Dirs()
        self.files = Files(self.dirs)

        if self.files.outdir.line(0):
            self.settings.OutDir = self.files.outdir.line(0)

        if not os.path.isdir(self.settings.OutDir):
            os.makedirs(self.settings.OutDir)

        if self.files.media.line(0):
            self.settings.MediaDir = self.files.media.line(0)

        Siter.info('Output dir is {}'.format(self.settings.OutDir))

        def copy_media(src_dir, dst):
            if os.path.isdir(src_dir.path):
                src = src_dir.path + '/'
                dst = self.settings.OutDir + '/' + dst

                Siter.info('Copying media from {} to {}'.format(src, dst))
                os.system('rsync -r --delete {} {}'.format(src, dst))

        # Copy site and template media files
        copy_media(self.dirs.media, self.settings.MediaDir)
        copy_media(self.dirs.template_media, self.settings.MediaDir + '/' + 'template-media')

        if self.files.marker.line(0):
            self.settings.Marker = self.files.marker.line(0)

        if self.files.tags.line(0) and self.files.tags.line(1):
            self.settings.TagOpen = Tag(self.files.tags.line(0))
            self.settings.TagClose = Tag(self.files.tags.line(1))

            Siter.info('Using {} and {} as block tags'
                .format(self.settings.TagOpen.raw, self.settings.TagClose.raw))

        # Calling a function or variable: <name> <arguments>
        self.re_use = re.compile('([\w\.\-]+)\s*'
                                 + '(.*)'
                                 + '$',
                                 re.DOTALL)

        # Declaring a variable: <name> <contents>
        self.re_var = re.compile('([\w\.\-]+)\s*'
                                 + '(.*)'
                                 + '$',
                                 re.DOTALL)

        # Declaring a function: <name> {parameters} <body>
        self.re_fun = re.compile('([\w\.\-]+)\s*'
                                 + self.settings.TagOpen.escaped
                                 + '(.*?)'
                                 + self.settings.TagClose.escaped
                                 + '\s*'
                                 + '(.*)'
                                 + '$',
                                 re.DOTALL)

        # s.if <binding> <body>
        self.re_if = re.compile('s\.if\s+([\w\.\-]+)\s+'
                                + '(.*)'
                                + '$',
                                re.DOTALL)

        # s.ifnot <binding> <body>
        self.re_ifnot = re.compile('s\.ifnot\s+([\w\.\-]+)\s+'
                                   + '(.*)'
                                   + '$',
                                   re.DOTALL)

        # Global function and variable bindings
        self.bindings = self.get_bindings(self.files.defs.path)

    def extract_blocks(self, text):
        # A block is a "{something}" that may contain other "{somethings}"
        blocks = []

        count = 0
        start = 0
        index = 0

        while index < len(text):
            index_open = text.find(self.settings.TagOpen.raw, index)
            index_close = text.find(self.settings.TagClose.raw, index)

            if index_open == -1 and index_close == -1:
                # No more tags found
                break

            if (index_open < index_close and index_open != -1) or index_close == -1:
                if count == 0:
                    # Current block starts here
                    start = index_open

                count += 1
                index = index_open + self.settings.TagClose.length
            elif (index_close < index_open and index_close != -1) or index_open == -1:
                count -= 1
                index = index_close + self.settings.TagClose.length

            if count == 0:
                blocks.append(
                    Block(self, text[start : index_close + self.settings.TagClose.length])
                )

        return blocks

    def evaluate_text(self, text, bindings):
        for block in self.extract_blocks(text):
            ifso = self.re_if.match(block.content)
            ifnot = self.re_ifnot.match(block.content)
            use = self.re_use.match(block.content)

            if ifso:
                check = ifso.group(1)
                body = ifso.group(2)

                if check not in bindings:
                    # Conditional failed, discard the block
                    text = text.replace(block.whole, '', 1)
                    continue

                # Evaluate the conditional body, then replace the block with it
                body = self.evaluate_text(body, bindings)
                text = text.replace(block.whole, body, 1)
            elif ifnot:
                check = ifnot.group(1)
                body = ifnot.group(2)

                if check in bindings:
                    # Conditional failed, discard the block
                    text = text.replace(block.whole, '', 1)
                    continue

                # Evaluate the conditional body, then replace the block with it
                body = self.evaluate_text(body, bindings)
                text = text.replace(block.whole, body, 1)
            elif use:
                name = use.group(1)
                args = use.group(2)

                if name not in bindings:
                    # Name is unknown, discard the block
                    text = text.replace(block.whole, '', 1)
                    continue

                binding = bindings[name]

                # Avoid infinite recursion
                del bindings[name]

                if binding.is_var:
                    body = self.evaluate_text(binding.body, bindings)

                    if name == 's.content':
                        try:
                            import markdown
                            body = markdown.markdown(body, output_format = 'html5')
                        except ImportError:
                            pass

                    text = text.replace(block.whole, body, 1)
                elif binding.is_macro or binding.is_func:
                    arg_blocks = self.extract_blocks(args)

                    # You can pass 1 argument without block tags
                    if len(arg_blocks) == 0 and len(args) > 0:
                        arg_blocks.append(Block(self, args))

                    if binding.is_macro and len(arg_blocks) != len(binding.params):
                        Siter.warning('{} takes {} args, got {}'
                            .format(name, len(binding.params), len(arg_blocks)))
                    elif binding.is_func and binding.params > 0 and len(arg_blocks) != binding.params:
                        Siter.warning('{} takes {} args, got {}'
                            .format(name, binding.params, len(arg_blocks)))
                    else:
                        arguments = []

                        # Evaluate each argument
                        for arg_block in arg_blocks:
                            arg = self.evaluate_text(arg_block.content, bindings)
                            arguments.append(arg)

                        if binding.is_macro:
                            bindings2 = dict(bindings)

                            # Bind each parameter to the supplied argument
                            for (i, param) in enumerate(binding.params):
                                bindings2[param] = Binding(body = arguments[i])

                            body = self.evaluate_text(binding.body, bindings2)
                        elif binding.is_func:
                            body = binding.func(arguments)

                        text = text.replace(block.whole, body, 1)
                else:
                    Siter.error('Cannot eval binding {}'.format(name))

                # Restore binding
                bindings[name] = binding

        return text

    def get_bindings(self, read_file):
        if not os.path.isfile(read_file):
            return {}

        with open(read_file, 'rU') as f:
            text = f.read()

        start = 0

        # "name" -> Binding object
        bindings = {}

        # Find the content-start marker
        marker = text.find(self.settings.Marker)

        if marker != -1:
            bindings['s.content'] = Binding(body = text[marker + len(self.settings.Marker) :])
            text = text[: marker]

        for block in self.extract_blocks(text):
            var = self.re_var.match(block.content)
            fun = self.re_fun.match(block.content)

            if fun:
                name = fun.group(1)
                params = fun.group(2).split()
                body = fun.group(3)
                bindings[name] = Binding(params = params, body = body)
            elif var:
                name = var.group(1)
                bindings[name] = Binding(body = var.group(2))
            else:
                Siter.error('Cannot parse block:\n{}'.format(block.whole))

        return bindings

    def apply_template(self, template_file, bindings, subdir):
        # This way links and media paths work in subdir pages too
        root_path = os.path.relpath(self.settings.OutDir,
                                    os.path.join(self.settings.OutDir, subdir))

        # Built-in bindings
        bindings['s.root'] = Binding(body = root_path)
        bindings['s.media'] = Binding(body = root_path + '/' + self.settings.MediaDir)

        # Fill in template
        template = self.evaluate_text(template_file.content, bindings)

        return template

    def up_to_date(self, read_file, write_file):
        if not self.settings.Force and os.path.isfile(write_file):
            read_date = os.stat(read_file).st_mtime
            write_date = os.stat(write_file).st_mtime

            return read_date < write_date
        else:
            return False

    def highlight_code(self, args):
        if len(args) == 1:
            lang = 'text'
            code = args[0]
            lines = []
        elif len(args) == 2:
            lang = args[0]
            code = args[1]
            lines = []
        elif len(args) == 3:
            lang = args[0]
            code = args[2]
            lines = args[1].split()
        else:
            Siter.warning('s.code takes 1-3 args, got {}'.format(len(args)))
            return ''

        def clean_code(code):
            # Replace < and > with HTML entities
            code = code.replace('<', '&lt;')
            code = code.replace('>', '&gt;')
            return code

        if code.find('\n') == -1:
            # This is a one-liner
            code = '<code>' + clean_code(code) + '</code>'
        else:
            # This is a code block
            div_class = 'siter_code'

            try:
                import pygments, pygments.formatters, pygments.lexers
            except ImportError:
                # Can't import Pygments, use a simple fallback
                code = '<div class="' + div_class + '"><pre>' + clean_code(code) + '</pre></div>'
            else:
                lexer = pygments.lexers.get_lexer_by_name(lang.lower())
                formatter = pygments.formatters.HtmlFormatter(linenos = True, cssclass = div_class, hl_lines=lines)
                code = pygments.highlight(code, lexer, formatter)

        return code

    def run(self, subdir):
        in_path = os.path.join(self.dirs.pages.path, subdir)
        out_path = os.path.join(self.settings.OutDir, subdir)

        pages = os.listdir(in_path)
        pages.sort(key = lambda p: p)

        for p in pages:
            read_file = in_path + '/' + p
            write_file = out_path + '/' + p

            if os.path.isdir(read_file):
                self.run(subdir + '/' + p)
                continue

            if self.up_to_date(read_file, write_file):
                print('[ Up to date ] {}'.format(write_file))
                continue

            print('[  Updating  ] {}'.format(write_file))

            # Go through page file and extract bindings
            bindings = dict(list(self.bindings.items()) + list(self.get_bindings(read_file).items()))

            # Built-in bindings
            bindings['s.modified'] = Binding(
                params = 1,
                func = lambda args: time.strftime(args[0], time.localtime(os.stat(read_file).st_mtime))
            )
            bindings['s.generated'] = Binding(
                params = 1,
                func = lambda args: time.strftime(args[0])
            )
            bindings['s.code'] = Binding(
                params = 0,
                func = self.highlight_code
            )

            # Load template and replace variables and functions with bindings
            page = self.apply_template(self.files.page_html, bindings, subdir)

            os.makedirs(out_path, exist_ok = True)

            with open(write_file, 'w') as f:
                f.write(page)

if __name__ == '__main__':
    siter = Siter(sys.argv[1] if len(sys.argv) > 1 else None)
    siter.run('.')

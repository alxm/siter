#!/usr/bin/env python3

"""
    Copyright 2011 Alex Margarit

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""

import sys
import os
import re
import time
import shutil
import importlib

class File:
    def __init__(self, path, required = False):
        self.path = path
        self.required = required

        if self.required and not os.path.exists(self.path):
            Siter.error('Required file {} not found'.format(self.path))

class Dir(File):
    def add_file(self, name, required = False):
        path = os.path.join(self.path, name)
        return TextFile(path, required)

    def copy_to(self, dst_dir):
        src = self.path + '/'
        dst = dst_dir.path

        Siter.info('Copying media from {} to {}'.format(src, dst))
        os.system('rsync -r --delete {} {}'.format(src, dst))

class TextFile(File):
    def __init__(self, path, required = False):
        File.__init__(self, path, required)

        self.lines = []
        self.content = ''

        try:
            with open(self.path, 'rU') as f:
                for line in f:
                    line = line.strip()
                    self.lines.append(line if len(line) > 0 else None)

                f.seek(0)
                self.content = f.read()
        except FileNotFoundError:
            if self.required:
                Siter.error('Required file {} not found'.format(self.path))

    def line(self, number):
        if number < len(self.lines):
            return self.lines[number]
        elif self.required:
            Siter.error('Missing required line {}:{}'.format(self.path, number))
        else:
            return None

class Dirs:
    def __init__(self):
        self.config = Dir('siter-config')
        self.media = Dir('siter-media')
        self.pages = Dir('siter-pages', True)
        self.template = Dir('siter-template', True)
        self.template_media = Dir('siter-template/media')

        self.out_root = Dir('siter-out')
        self.out_media = Dir('siter-out/media')
        self.out_template_media = Dir('siter-out/media/template-media')

class Files:
    def __init__(self, dirs):
        self.defs = dirs.config.add_file('defs')
        self.marker = dirs.config.add_file('marker')
        self.media = dirs.config.add_file('media')
        self.outdir = dirs.config.add_file('outdir')
        self.tags = dirs.config.add_file('tags')
        self.page_html = dirs.template.add_file('page.html', True)

class Tag:
    def __init__(self, text):
        self.raw = text
        self.escaped = re.escape(text)
        self.size = len(text)

class Block:
    def __init__(self, siter, text):
        # Add block tags if missing
        if text.find(siter.TagOpen.raw) != 0:
            text = siter.TagOpen.raw + text + siter.TagClose.raw

        # Block including { and }
        self.whole = text

        # Just the inside of { ... }
        self.content = text[siter.TagOpen.size : -siter.TagClose.size].strip()

class Binding:
    def __init__(self, body = None, num_params = 0, params = None, func = None):
        if body is not None:
            body = body.strip()

        self.body = body
        self.num_params = len(params) if params is not None else num_params
        self.params = params
        self.func = func

        self.is_var = body is not None and params is None
        self.is_macro = body is not None and params is not None
        self.is_func = func is not None

class BuiltInFunctions:
    @staticmethod
    def highlight_code(siter, args):
        if len(args) == 1:
            lang = 'text'
            code = args[0]
            lines = []
        elif len(args) == 2:
            lang = args[0]
            code = args[1]
            lines = []
        elif len(args) == 3:
            lang = args[0]
            code = args[2]
            lines = args[1].split()
        else:
            Siter.warning('s.code takes 1-3 args, got {}'.format(len(args)))
            return ''

        def clean_code(code):
            # Replace < and > with HTML entities
            code = code.replace('<', '&lt;')
            code = code.replace('>', '&gt;')
            return code

        if code.find('\n') == -1:
            # This is a one-liner
            code = '<code>{}</code>'.format(clean_code(code))
        else:
            # This is a code block
            div_class = 'siter_code'

            if siter.Pygments:
                lexer = siter.PygmentsLexers.get_lexer_by_name(lang.lower())
                formatter = siter.PygmentsFormatters.HtmlFormatter(
                    linenos = True, cssclass = div_class, hl_lines=lines)
                code = siter.Pygments.highlight(code, lexer, formatter)
            else:
                code = '<div class="{}"><pre>{}</pre></div>' \
                    .format(div_class, clean_code(code))

        return code

class Siter:
    @staticmethod
    def error(e):
        print('[   Error!   ] {}'.format(e))
        sys.exit(1)

    @staticmethod
    def warning(w):
        print('[  Warning!  ] {}'.format(w))

    @staticmethod
    def info(m):
        print('[    Info    ] {}'.format(m))

    def __init__(self, arg):
        # Whether to re-generate up-to-date files
        self.ForceWrite = arg == 'force'

        # Block delimiters
        self.TagOpen = Tag('{')
        self.TagClose = Tag('}')

        # Marks the beginning of page content
        self.Marker = '~~~'

        self.dirs = Dirs()
        self.files = Files(self.dirs)

        os.makedirs(self.dirs.out_root.path, exist_ok = True)

        # Copy site and template media files
        self.dirs.media.copy_to(self.dirs.out_media)
        self.dirs.template_media.copy_to(self.dirs.out_template_media)

        if self.files.marker.line(0):
            self.Marker = self.files.marker.line(0)

        if self.files.tags.line(0) and self.files.tags.line(1):
            self.TagOpen = Tag(self.files.tags.line(0))
            self.TagClose = Tag(self.files.tags.line(1))

            Siter.info('Using {} and {} as block tags'
                .format(self.TagOpen.raw, self.TagClose.raw))

        # Calling a function or variable: <name> <arguments>
        self.re_use = re.compile('([\w\.\-]+)\s*'
                                 + '(.*)'
                                 + '$',
                                 re.DOTALL)

        # Declaring a variable: <name> <contents>
        self.re_var = re.compile('([\w\.\-]+)\s*'
                                 + '(.*)'
                                 + '$',
                                 re.DOTALL)

        # Declaring a function: <name> {parameters} <body>
        self.re_fun = re.compile('([\w\.\-]+)\s*'
                                 + self.TagOpen.escaped
                                 + '(.*?)'
                                 + self.TagClose.escaped
                                 + '\s*'
                                 + '(.*)'
                                 + '$',
                                 re.DOTALL)

        # Global function and variable bindings
        self.bindings = self.get_bindings(self.files.defs.path)

        def try_import(module):
            try:
                return importlib.import_module(module)
            except ImportError:
                return None

        self.Md = try_import('markdown')
        self.Pygments = try_import('pygments')
        self.PygmentsLexers = try_import('pygments.lexers')
        self.PygmentsFormatters = try_import('pygments.formatters')

    def extract_blocks(self, text):
        # A block is a "{something}" that may contain other "{somethings}"
        blocks = []

        count = 0
        start = 0
        index = 0

        while index < len(text):
            i_open = text.find(self.TagOpen.raw, index)
            i_close = text.find(self.TagClose.raw, index)

            if i_open == -1 and i_close == -1:
                # No more tags found
                break

            if (i_open < i_close and i_open != -1) or i_close == -1:
                if count == 0:
                    # Current block starts here
                    start = i_open

                count += 1
                index = i_open + self.TagClose.size
            elif (i_close < i_open and i_close != -1) or i_open == -1:
                count -= 1
                index = i_close + self.TagClose.size

            if count == 0:
                blocks.append(
                    Block(self, text[start : i_close + self.TagClose.size])
                )

        return blocks

    def evaluate_text(self, text, bindings):
        for block in self.extract_blocks(text):
            # <name> <arguments>
            use = self.re_use.match(block.content)

            if not use:
                continue

            name = use.group(1)
            args = use.group(2)

            if name not in bindings:
                # Name is unknown, discard the block
                text = text.replace(block.whole, '', 1)
                continue

            binding = bindings[name]

            if binding.is_var:
                body = self.evaluate_text(binding.body, bindings)

                if name == 's.content':
                    if self.Md:
                        body = self.Md.markdown(body, output_format = 'html5')

                text = text.replace(block.whole, body, 1)
            elif binding.is_macro:
                arg_blocks = self.extract_blocks(args)

                # You can pass 1 argument without block tags
                if len(arg_blocks) == 0 and len(args) > 0:
                    arg_blocks.append(Block(self, args))

                if len(arg_blocks) != binding.num_params:
                    Siter.warning('Macro {} takes {} args, got {}'
                        .format(name, binding.num_params, len(arg_blocks)))
                    continue

                arguments = []

                # Evaluate each argument
                for arg_block in arg_blocks:
                    arg = self.evaluate_text(arg_block.content, bindings)
                    arguments.append(arg)

                bindings2 = bindings.copy()

                # Bind each parameter to the supplied argument
                for (i, param) in enumerate(binding.params):
                    bindings2[param] = Binding(body = arguments[i])

                body = self.evaluate_text(binding.body, bindings2)
                text = text.replace(block.whole, body, 1)
            elif binding.is_func:
                arg_blocks = self.extract_blocks(args)

                # You can pass 1 argument without block tags
                if len(arg_blocks) == 0 and len(args) > 0:
                    arg_blocks.append(Block(self, args))

                if len(arg_blocks) != binding.num_params:
                    # -1 means arbitrary number of parameters
                    if binding.num_params != -1:
                        Siter.warning('Function {} takes {} args, got {}'
                            .format(name, binding.num_params, len(arg_blocks)))
                        continue

                arguments = []

                # Evaluate each argument
                for arg_block in arg_blocks:
                    arg = self.evaluate_text(arg_block.content, bindings)
                    arguments.append(arg)

                body = binding.func(self, arguments)
                text = text.replace(block.whole, body, 1)
            else:
                Siter.error('Cannot eval binding {}'.format(name))

        return text

    def get_bindings(self, read_file):
        try:
            with open(read_file, 'rU') as f:
                text = f.read()
        except FileNotFoundError:
            return {}

        start = 0

        # "name" -> Binding object
        bindings = {}

        # Find the content-start marker
        marker = text.find(self.Marker)

        if marker != -1:
            bindings['s.content'] = Binding(
                body = text[marker + len(self.Marker) :])
            text = text[: marker]

        for block in self.extract_blocks(text):
            var = self.re_var.match(block.content)
            fun = self.re_fun.match(block.content)

            if fun:
                name = fun.group(1)
                params = fun.group(2).split()
                body = fun.group(3)
                bindings[name] = Binding(params = params, body = body)
            elif var:
                name = var.group(1)
                bindings[name] = Binding(body = var.group(2))
            else:
                Siter.error('Cannot parse block:\n{}'.format(block.whole))

        return bindings

    def apply_template(self, template_file, bindings, subdir):
        current_path = os.path.join(self.dirs.out_root.path, subdir)
        rel_root_path = os.path.relpath(self.dirs.out_root.path, current_path)
        rel_media_path = os.path.relpath(self.dirs.out_media.path, current_path)

        # Built-in bindings
        bindings['s.root'] = Binding(body = rel_root_path)
        bindings['s.media'] = Binding(body = rel_media_path)

        # Fill in template
        template = self.evaluate_text(template_file.content, bindings)

        return template

    def up_to_date(self, read_file, write_file):
        if not self.ForceWrite and os.path.isfile(write_file):
            read_date = os.stat(read_file).st_mtime
            write_date = os.stat(write_file).st_mtime

            return read_date < write_date
        else:
            return False

    def run(self, subdir):
        in_path = os.path.join(self.dirs.pages.path, subdir)
        out_path = os.path.join(self.dirs.out_root.path, subdir)

        os.makedirs(out_path, exist_ok = True)

        for page in sorted(os.listdir(in_path)):
            read_file = os.path.join(in_path, page)
            write_file = os.path.join(out_path, page)

            if os.path.isdir(read_file):
                self.run(os.path.join(subdir, page))
                continue

            if self.up_to_date(read_file, write_file):
                print('[ Up to date ] {}'.format(write_file))
                continue

            print('[  Updating  ] {}'.format(write_file))

            # Go through page file and extract bindings
            bindings = self.bindings.copy()
            bindings.update(self.get_bindings(read_file))

            # Built-in bindings
            bindings['s.if'] = Binding(
                num_params = 2,
                func = lambda _, args: args[1] if args[0] in bindings else ''
            )
            bindings['s.ifnot'] = Binding(
                num_params = 2,
                func = lambda _, args: '' if args[0] in bindings else args[1]
            )
            bindings['s.modified'] = Binding(
                num_params = 1,
                func = lambda _, args: time.strftime(
                    args[0], time.localtime(os.stat(read_file).st_mtime))
            )
            bindings['s.generated'] = Binding(
                num_params = 1,
                func = lambda _, args: time.strftime(args[0])
            )
            bindings['s.code'] = Binding(
                num_params = -1,
                func = BuiltInFunctions.highlight_code
            )

            # Load template and replace variables and functions with bindings
            final = self.apply_template(self.files.page_html, bindings, subdir)

            with open(write_file, 'w') as f:
                f.write(final)

if __name__ == '__main__':
    siter = Siter(sys.argv[1] if len(sys.argv) > 1 else None)
    siter.run('')

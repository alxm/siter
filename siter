#!/usr/bin/env python3

"""
    Copyright 2011 Alex Margarit

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""

import os, re, sys, shutil, time

class Siter:
    class Settings:
        # Whether to re-generate up-to-date files
        FORCE = False

        # Block delimiters
        TAG_OPEN = "{"
        TAG_CLOSE = "}"
        TAG_OPEN_ESC = re.escape(TAG_OPEN)
        TAG_CLOSE_ESC = re.escape(TAG_CLOSE)

        # Marks the beginning of page content
        MARKER = "~~~"

        # Where generated pages are written
        OUTDIR = "siter-out"

        # Subdir in siter-out for media content copied from siter-media
        MEDIADIR = "media"

    class Block:
        def __init__(self, siter, text):
            # Block including { and }
            self.whole = text

            # Just the inside of { ... }
            self.content = text[len(siter.settings.TAG_OPEN) : -len(siter.settings.TAG_CLOSE)]

    def __init__(self, arg):
        self.settings = self.Settings()

        if arg == "force":
            self.settings.FORCE = True

        # "label" -> (path, required)
        self.dirs = {
            "config": ("siter-config", False),
            "media": ("siter-media", False),
            "pages": ("siter-pages", True),
            "template": ("siter-template", True),
        }

        # "label" -> (path, required)
        self.files = {
            "defs": (self.getdir("config") + "/" + "defs", False),
            "marker": (self.getdir("config") + "/" + "marker", False),
            "media": (self.getdir("config") + "/" + "media", False),
            "outdir": (self.getdir("config") + "/" + "outdir", False),
            "tags": (self.getdir("config") + "/" + "tags", False),
            "template": (self.getdir("template") + "/" + "page.html", True),
        }

        for label, (path, required) in iter(self.dirs.items()):
            if required and not os.path.isdir(path):
                self.error("Can't find {0} dir".format(path))

        for label, (path, required) in iter(self.files.items()):
            if required and not os.path.isfile(path):
                self.error("Can't find {0} file".format(path))

        if os.path.isfile(self.getfile("outdir")):
            with open(self.getfile("outdir"), "rU") as f:
                out = f.readline().strip()

                if len(out) > 0:
                    self.settings.OUTDIR = out

        if not os.path.isdir(self.settings.OUTDIR):
            os.makedirs(self.settings.OUTDIR)

        if os.path.isfile(self.getfile("media")):
            with open(self.getfile("media"), "rU") as f:
                media = f.readline().strip()

                if len(media) > 0:
                    self.settings.MEDIADIR = media

        self.info("Output dir is {0}".format(self.settings.OUTDIR))

        # Copy media files
        os.system("rsync -r --delete {0} {1}".format(self.getdir("media") + "/", self.settings.OUTDIR + "/" + self.settings.MEDIADIR))

        if os.path.isfile(self.getfile("marker")):
            with open(self.getfile("marker"), "rU") as f:
                marker = f.readline().strip()

                if len(marker) > 0:
                    self.settings.MARKER = marker

        if os.path.isfile(self.getfile("tags")):
            with open(self.getfile("tags"), "rU") as f:
                tag_open = f.readline().strip()
                tag_close = f.readline().strip()

                if len(tag_open) == 0:
                    self.error("Custom open tag is an empty string")
                elif len(tag_close) == 0:
                    self.error("Custom close tag is an empty string")
                else:
                    self.info("Using {0} and {1} as tags".format(tag_open, tag_close))
                    self.settings.TAG_OPEN = tag_open
                    self.settings.TAG_CLOSE = tag_close
                    self.settings.TAG_OPEN_ESC = re.escape(tag_open)
                    self.settings.TAG_CLOSE_ESC = re.escape(tag_close)

        # Calling a function or variable: <name> <arguments>
        self.re_use = re.compile("([\w\.\-]+)\s*"
                                 + "(.*)"
                                 + "$",
                                 re.DOTALL)

        # Declaring a variable: <name> <contents>
        self.re_var = re.compile("([\w\.\-]+)\s*"
                                 + "(.*)"
                                 + "$",
                                 re.DOTALL)

        # Declaring a function: <name> {parameters} <body>
        self.re_fun = re.compile("([\w\.\-]+)\s*"
                                 + self.settings.TAG_OPEN_ESC
                                 + "(.*?)"
                                 + self.settings.TAG_CLOSE_ESC
                                 + "\s*"
                                 + "(.*)"
                                 + "$",
                                 re.DOTALL)

        # s.if <binding> <body>
        self.re_if = re.compile("s\.if\s+([\w\.\-]+)\s+"
                                + "(.*)"
                                + "$",
                                re.DOTALL)

        # s.ifnot <binding> <body>
        self.re_ifnot = re.compile("s\.ifnot\s+([\w\.\-]+)\s+"
                                   + "(.*)"
                                   + "$",
                                   re.DOTALL)

        # Global function and variable bindings
        self.bindings = self.get_bindings(self.getfile("defs"))

    def getdir(self, name):
        return self.dirs[name][0]

    def getfile(self, name):
        return self.files[name][0]

    def error(self, e):
        print("[   Error!   ] {0}".format(e))
        sys.exit(1)

    def warning(self, w):
        print("[  Warning!  ] {0}".format(w))

    def info(self, m):
        print("[    Info    ] {0}".format(m))

    def extract_blocks(self, text):
        # A block is a "{something}" that may contain other "{somethings}"
        blocks = []

        count = 0
        start = 0
        index = 0

        def find_tag(tag, text, index):
            while True:
                i = text.find(tag, index)

                # Ignore escaped tag
                if i > 0 and text[i - 1] == "\\":
                    index = i + len(tag)
                    continue
                else:
                    return i

        while index < len(text):

            index_open = find_tag(self.settings.TAG_OPEN, text, index)
            index_close = find_tag(self.settings.TAG_CLOSE, text, index)

            if index_open == -1 and index_close == -1:
                # No more tags found
                break

            if (index_open < index_close and index_open != -1) or index_close == -1:
                if count == 0:
                    # Current block starts here
                    start = index_open

                count += 1
                index = index_open + len(self.settings.TAG_OPEN)
            elif (index_close < index_open and index_close != -1) or index_open == -1:
                count -= 1
                index = index_close + len(self.settings.TAG_CLOSE)

            if count == 0:
                blocks.append(
                    self.Block(self,
                               text[start : index_close + len(self.settings.TAG_CLOSE)])
                )

        return blocks

    def evaluate_text(self, text, bindings):
        for block in self.extract_blocks(text):
            ifso = self.re_if.match(block.content)
            ifnot = self.re_ifnot.match(block.content)
            use = self.re_use.match(block.content)

            if ifso:
                check = ifso.group(1)
                body = ifso.group(2)

                if not check in bindings:
                    # Conditional failed, discard the block
                    text = text.replace(block.whole, "", 1)
                    continue

                # Evaluate the conditional body, then replace the block with it
                body = self.evaluate_text(body, bindings)
                text = text.replace(block.whole, body, 1)
            elif ifnot:
                check = ifnot.group(1)
                body = ifnot.group(2)

                if check in bindings:
                    # Conditional failed, discard the block
                    text = text.replace(block.whole, "", 1)
                    continue

                # Evaluate the conditional body, then replace the block with it
                body = self.evaluate_text(body, bindings)
                text = text.replace(block.whole, body, 1)
            elif use:
                name = use.group(1)
                args = use.group(2)

                if not name in bindings:
                    # Name is unknown, discard the block
                    text = text.replace(block.whole, "", 1)
                    continue

                (params, body, builtin_func) = bindings[name]

                bindings2 = dict(bindings)

                # Avoid infinite recursion
                del bindings2[name]

                # If this is a function
                if len(params) > 0:
                    arg_blocks = self.extract_blocks(args)

                    if len(arg_blocks) != len(params):
                        self.warning("{0} expects {1} arguments, got {2}"
                            .format(name, len(params), len(arg_blocks)))
                        continue

                    arguments = []

                    # Evaluate each argument
                    for arg_block in arg_blocks:
                        arg = self.evaluate_text(arg_block.content, bindings2)
                        arguments.append(arg)

                    if builtin_func is not None:
                        # Built-in functions have their own logic
                        body = builtin_func(arguments)
                    else:
                        # Replace every instance of a parameter with the supplied argument
                        for i in range(len(arguments)):
                            for m in re.finditer(self.settings.TAG_OPEN_ESC
                                                 + "\s*" + params[i] + "\s*"
                                                 + self.settings.TAG_CLOSE_ESC,
                                                 body, re.DOTALL):
                                body = body.replace(m.group(), arguments[i], 1)

                # Evaluate the function body, then replace the block with it
                body = self.evaluate_text(body, bindings2)
                text = text.replace(block.whole, body, 1)

        return text

    def get_bindings(self, read_file):
        if not os.path.isfile(read_file):
            return {}

        with open(read_file, "rU") as f:
            text = f.read()

        start = 0

        # "name" -> ([params], body, lambda)
        bindings = {}

        # Find the content-start marker
        marker = text.find(self.settings.MARKER)

        if marker != -1:
            bindings["s.content"] = ([], text[marker + len(self.settings.MARKER) :].strip(), None)
            text = text[: marker]

        for block in self.extract_blocks(text):
            var = self.re_var.match(block.content)
            fun = self.re_fun.match(block.content)

            if fun:
                name = fun.group(1)
                params = [p for p in re.split("\s+", fun.group(2).strip())]
                body = fun.group(3)
                bindings[name] = (params, body, None)
            elif var:
                name = var.group(1)
                bindings[name] = ([], var.group(2), None)
            else:
                self.error("Block is neither variable nor function\n{0}"
                    .format(block.whole))

        return bindings

    def apply_template(self, name, bindings, subdir):
        with open(self.getfile(name), "rU") as f:
            template = f.read()

        # This way links and media paths work in subdir pages too
        root_path = os.path.relpath(self.settings.OUTDIR, self.settings.OUTDIR + "/" + subdir)

        # Built-in bindings
        # "name" -> ([params], body, lambda)
        bindings["s.root"] = (
            [],
            root_path,
            None
        )
        bindings["s.media"] = (
            [],
            root_path + "/" + self.settings.MEDIADIR,
            None
        )

        # Fill in template
        template = self.evaluate_text(template, bindings)

        # Strip escape chars
        template = re.sub(r'\\(.)', r'\1', template)

        return template

    def up_to_date(self, read_file, write_file):
        if not self.settings.FORCE and os.path.isfile(write_file):
            read_date = os.stat(read_file).st_mtime
            write_date = os.stat(write_file).st_mtime

            return read_date < write_date
        else:
            return False

    def highlight_code(self, lang, code):
        try:
            import pygments, pygments.formatters, pygments.lexers
        except ImportError:
            # Replace < and > with HTML entities
            code = code.replace("<", "&lt;")
            code = code.replace(">", "&gt;")

            code = '<div class="siter_code"><pre>' + code.strip() + '</pre></div>'
        else:
            lexer = pygments.lexers.get_lexer_by_name(lang.lower().strip(), stripall = True)
            formatter = pygments.formatters.HtmlFormatter(linenos = True, cssclass = "siter_code")
            code = pygments.highlight(code, lexer, formatter)

        return '<div class="siter_code_container">' + code + '</div>'

    def run(self, subdir):
        pages = os.listdir(self.getdir("pages") + "/" + subdir)
        pages.sort(key = lambda p: p)

        for p in pages:
            read_file = self.getdir("pages") + "/" + subdir + "/" + p
            write_file = self.settings.OUTDIR + "/" + subdir + "/" + p

            if os.path.isdir(read_file):
                self.run(subdir + "/" + p)
                continue

            if self.up_to_date(read_file, write_file):
                print("[ Up to date ] " + write_file)
                continue

            print("[  Updating  ] " + write_file)

            # Go through page file and extract s.var and s.fun bindings
            bindings = dict(list(self.bindings.items()) + list(self.get_bindings(read_file).items()))

            # Built-in bindings
            # "name" -> ([params], body, lambda)
            bindings["s.modified"] = (
                ["fmt"],
                None,
                lambda args: time.strftime(args[0], time.localtime(os.stat(read_file).st_mtime))
            )
            bindings["s.generated"] = (
                ["fmt"],
                None,
                lambda args: time.strftime(args[0])
            )
            bindings["s.code"] = (
                ["lang", "code"],
                None,
                lambda args: self.highlight_code(args[0], args[1])
            )

            # Load template and replace variables and functions with bindings
            page = self.apply_template("template", bindings, subdir)

            if not os.path.isdir(self.settings.OUTDIR + "/" + subdir):
                os.makedirs(self.settings.OUTDIR + "/" + subdir)

            with open(write_file, "w") as f:
                f.write(page)

if __name__ == "__main__":
    siter = Siter(sys.argv[1] if len(sys.argv) > 1 else None)
    siter.run(".")

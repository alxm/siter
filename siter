#!/usr/bin/env python

"""
    Copyright 2011 Alex Margarit

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""

import os, re, sys, time

class Block:
    TAG_OPEN = "(("
    TAG_CLOSE = "))"

    TAG_OPEN_E = re.escape(TAG_OPEN)
    TAG_CLOSE_E = re.escape(TAG_CLOSE)

    def __init__(self, text):
        # Block including TAG_OPEN and TAG_CLOSE
        self.whole = text

        # Just the inside of TAG_OPEN ... TAG_CLOSE
        self.content = text[len(Block.TAG_OPEN) : -len(Block.TAG_CLOSE)].strip()

    @staticmethod
    def extract_blocks(text):
        # A block is a root-level ((something))
        blocks = []

        count = 0
        start = 0
        index = 0

        while index < len(text):
            def find_tag(tag, text, index):
                while True:
                    i = text.find(tag, index)

                    # Ignore escaped tag
                    if i > 0 and text[i - 1] == "\\":
                        index = i + len(tag)
                        continue
                    else:
                        return i

            index_open = find_tag(Block.TAG_OPEN, text, index)
            index_close = find_tag(Block.TAG_CLOSE, text, index)

            if index_open == -1 and index_close == -1:
                # No more tags found
                break

            if (index_open < index_close and index_open != -1) or index_close == -1:
                if count == 0:
                    # Current block starts here
                    start = index_open

                count += 1
                index = index_open + len(Block.TAG_OPEN)
            elif (index_close < index_open and index_close != -1) or index_open == -1:
                count -= 1
                index = index_close + len(Block.TAG_CLOSE)

            if count == 0:
                blocks.append(Block(text[start : index_close + len(Block.TAG_CLOSE)]))

        return blocks

class Siter:
    def __init__(self, arg):
        self.arg_force = arg == "force"

        self.pages_dir = "siter-pages/"
        self.template_dir = "siter-template/"

        for d in [self.pages_dir, self.template_dir]:
            if not os.path.isdir(d):
                self.error("Can't find dir {0}".format(d))

    def error(self, e):
        print "[   Error!   ] {0}".format(e)
        sys.exit(1)

    def warning(self, w):
        print "[  Warning!  ] {0}".format(w)

    def evaluate_text(self, text, bindings):
        re_use = re.compile("s\.use\s+([\w\.\-]+)\s*(.*)$", re.DOTALL)

        for block in Block.extract_blocks(text):
            use = re_use.match(block.content)

            if use:
                name = use.group(1)
                args = use.group(2)
            else:
                continue

            if not name in bindings:
                text = text.replace(block.whole, "", 1)
                print "[ Can't find ] {0}".format(name)
                continue

            (params, body) = bindings[name]

            bindings2 = dict(bindings)

            # Avoid infinite recursion
            del bindings2[name]

            # If this is a function
            if len(params) > 0:
                arg_blocks = Block.extract_blocks(args)

                if len(arg_blocks) != len(params):
                    self.warning("{0} expects {1} arguments, got {2}"
                        .format(name, len(params), len(arg_blocks)))
                    continue

                arguments = []

                # Evaluate each argument
                for arg_block in arg_blocks:
                    arg = self.evaluate_text(arg_block.content, bindings2)
                    arguments.append(arg)

                # Replace every instance of a parameter with the supplied argument
                for i in range(len(arguments)):
                    for m in re.finditer(Block.TAG_OPEN_E
                                         + "s\.use\s+" + params[i] + "\s*"
                                         + Block.TAG_CLOSE_E,
                                         body, re.DOTALL):
                        body = body.replace(m.group(), arguments[i], 1)

            # Evaluate the body itself, then replace the ((block)) with it
            body = self.evaluate_text(body, bindings2)
            text = text.replace(block.whole, body, 1)

        return text

    def get_bindings(self, read_file):
        re_var = re.compile("s\.var\s+([\w\.\-]+)\s*"
                            + Block.TAG_OPEN_E
                            + "(.*)"
                            + Block.TAG_CLOSE_E
                            + "$",
                            re.DOTALL)
        re_fun = re.compile("s\.fun\s+([\w\.\-]+)\s*"
                            + Block.TAG_OPEN_E
                            + "(.*?)"
                            + Block.TAG_CLOSE_E
                            + "\s*"
                            + Block.TAG_OPEN_E
                            + "(.*)"
                            + Block.TAG_CLOSE_E
                            + "$",
                            re.DOTALL)

        with open(read_file, "rU") as f:
            text = f.read()

        start = 0

        # "name" -> ([params], body)
        bindings = {}

        for block in Block.extract_blocks(text):
            var = re_var.match(block.content)
            fun = re_fun.match(block.content)

            if var:
                name = var.group(1)
                bindings[name] = ([], var.group(2))
            elif fun:
                name = fun.group(1)
                params = [p for p in re.split("\s+", fun.group(2).strip())]
                body = fun.group(3)
                bindings[name] = (params, body)
            else:
                self.error("Block is neither variable nor function\n{0}"
                    .format(block.whole))

        return bindings

    def apply_template(self, name, bindings):
        template_file = self.template_dir + name

        if not os.path.isfile(template_file):
            self.error("Can't find page template {0}".format(template_file))

        with open(template_file, "rU") as f:
            template = f.read()

        # This way paths work in both the template dir and in generated pages
        template = template.replace('="./', '="siter-template/')

        template = self.evaluate_text(template, bindings)

        # Strip escape chars
        template = re.sub(r'\\(.)', r'\1', template)

        return template

    def up_to_date(self, read_file, write_file):
        if not self.arg_force and os.path.isfile(write_file):
            read_date = os.stat(read_file).st_mtime
            write_date = os.stat(write_file).st_mtime

            return read_date < write_date
        else:
            return False

    def run(self):
        pages = os.listdir(self.pages_dir)
        pages.sort(key = lambda p: p)

        for p in pages:
            read_file = self.pages_dir + p
            write_file = p

            if os.path.isdir(read_file):
                print "[  Skip dir  ] " + p
                continue

            if self.up_to_date(read_file, write_file):
                print "[ Up to date ] " + write_file
                continue

            print "[  Updating  ] " + write_file

            # Go through page file and extract s.var and s.fun bindings
            bindings = self.get_bindings(read_file)

            # Built-in bindings - "name" -> ([params], body)
            bindings["s.modified"] = ([], time.strftime("%Y.%m.%d", time.localtime(os.stat(read_file).st_mtime)))
            bindings["s.generated"] = ([], time.strftime("%Y.%m.%d"))

            # Load template and replace s.use instances with bindings
            page = self.apply_template("page.html", bindings)

            with open(write_file, "w") as f:
                f.write(page)

if __name__ == "__main__":
    siter = Siter(sys.argv[1] if len(sys.argv) > 1 else None)
    siter.run()
